Encapsulation (Data Hiding)
Encapsulation is a fundamental concept in object-oriented programming (OOP)
where the internal details (data and logic) of an object are hidden from the outside world.
It is the process of bundling the object's data (attributes) and methods (functions) together into a single unit or class. 
The primary goal is to protect the internal state of an object from unintended modifications and provide controlled access to it.

In simple terms, encapsulation ensures that the object's internal workings are hidden from other objects,
allowing external entities to interact with the object only through well-defined interfaces (methods).

Key Concept:
Encapsulation enforces data hiding and ensures that attributes (variables) within a class are not directly accessible to other classes or external code.
Instead, it provides getter and setter methods to access and modify these private attributes.
By making attributes private, encapsulation maintains control over how the data is accessed and modified, preventing unwanted changes or access.

For example:
Private attributes (fields) ensure that no one can directly alter the object's state.
Public getter and setter methods allow controlled access and modification of private attributes,
enabling additional business logic or validation during the process.

#Encapsulation_Problem.
import java.util.*;
class Book {
    private List<Boolean> isAvailable; // List of availability status
    public List<String> title;
    public List<String> author;
    // Constructor
    public Book(List<String> title, List<String> author, List<Boolean> isAvailable) {
        this.title = title;
        this.author = author;
        this.isAvailable = isAvailable;
    }
    // Method to borrow a book by its name
    public void borrowBook(String bookName) {
        for (int i = 0; i < title.size(); i++) {
            if (title.get(i).equals(bookName)) {
                if (isAvailable.get(i)) {
                    isAvailable.set(i, false);
                    return;
                } else {
                    System.out.println("Book is not available.");
                    return;
                }
            }
        }
        System.out.println("Book is not available.");
    }
    // Method to return a book by its name
    public void returnBook(String bookName) {
        for (int i = 0; i < title.size(); i++) {
            if (title.get(i).equals(bookName)) {
                if (!isAvailable.get(i)) {
                    isAvailable.set(i, true);
                    return;
                }
            }
        }
    }
    // Method to get the availability of a book by its name
    public void getAvailability(String bookName) {
        for (int i = 0; i < title.size(); i++) {
            if (title.get(i).equals(bookName)) {
                if (isAvailable.get(i)) {
                    System.out.println("true");
                    return;
                }
            }
        }
        System.out.println("false");
    }
}
public class Main {
    public static void main(String[] args) {
        List<String> title = Arrays.asList(
            "Sherlock_Holmes",
            "Frankenstein",
            "King_Arthur_and_the_Round_Table",
            "Treasure_Island"
        );
        List<String> author = Arrays.asList(
            "Arthur_Conan_Doyle",
            "Mary_Shelley",
            "Roger_Lancelyn_Green",
            "Robert_Louis_Stevenson"
        );
        List<Boolean> isAvailable = Arrays.asList(
            false,
            true,
            false,
            false
        );
        Book book = new Book(title, author, new ArrayList<>(isAvailable));
        // methodCalls
        book.borrowBook("Frankenstein");                       // Valid borrow
        book.borrowBook("Sherlock_Holmes");                    // Not available
        book.returnBook("King_Arthur_and_the_Round_Table");    // Return
        book.getAvailability("Sherlock_Holmes");               // Should be false
        book.borrowBook("Frankenstein");                       // Already borrowed
    }
}
